import math
from collections import Counter

"""
The following is a grepper answer by Noah's Nerdy KnowHow:
https://www.codegrepper.com/profile/noahs-nerdy-knowhow

The original function returned a dict, I added some code to make it a list.
"""
# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><
def primeFactors(num):
        ps = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,
        37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,
        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149]
        # Primes from https://primes.utm.edu/lists/small/10000.txt.
        # Primes can also be generated by iterating through numbers
        # and checking for factors, or by using a probabilistic test
        # like Rabin-Miller.
        pdict = {}
        for p in ps:
                if p <= num:
                        while (num / p).is_integer():
                                if str(p) in pdict:
                                        pdict[str(p)] += 1
                                else:
                                        pdict[str(p)] = 1
                                num /= p
                if num == 1: break
        
        """
        Added this to turn output to a raw list.
        """
        pList = []
        for i,key in enumerate(pdict):
            keys = list(pdict.keys())
            for n in range(0,pdict[key]):
                pList.append(int(keys[i]))
        return pList
# <><><><><><><><><><><><><><><><><><><><><><><><><><><>

"""
These functions find GCF (greatest common factor) or LCM (least common multiple)
of two numbers.

They do this by finding taking the elements of certain sets, then finding their product.

The GCF is the intersection of the prime factor sets.
The LCM is the union of these sets.

Technically, we could do this for any amount of numbers,
but I'm not sure the runtime's that good.
"""
def gcf(a,b):
    aFactors = primeFactors(a)
    bFactors = primeFactors(b)
    final = 1

    # "intersection" in python is not the same as it is in set theory :))))))
    intersectionSet = (Counter(aFactors) & Counter(bFactors)).elements()

    for fac in intersectionSet:
        final *= fac
    return final

def lcm(a,b):
    aFac = primeFactors(a)
    bFac = primeFactors(b)
    final = 1

    # Finds the union of the sets of prime factors.
    unionSet = (Counter(aFac) | Counter(bFac)).elements()
    
    for fac in unionSet:
        final *= fac
    return final

"""
Pretty self explanatory, parameter types below.

numerator (INT) numerator of the fraction to be simplified.
denomenator (INT) denomenator of the fraction to be simplified.
"""
def simplifyFraction(numerator,denomenator):
    factor = gcf(numerator,denomenator)
    newNum = int(numerator / factor)
    newDem = int(denomenator / factor)
    final = "{} / {}".format(newNum,newDem)
    return final


"""
The crown jewel of this whole file.
Solves long divison as follows:
    __________
    dividend | divisor

dividend (INT)
divisor (INT)
mode (INT 0-2)
> 0 - Returns the answer with a remainder ex. longDiv(63,4) --> 15 Remainder: 3
> 1 - Returns the answer as a mixed number ex. longDiv(63,4,mode=1) --> 15 3 / 4
> 2 - Returns the answer as a decimal ex. longDiv(63,4,mode=2) --> 15.75
"""
def longDiv(dividend,divisor,mode=0):        
    
    # Decimal division is the easiest on the checking side.
    quotient = dividend / divisor
    if mode == 2:
        return quotient
    
    # Isolating the fractional part from the whole part.
    rounded = math.floor(quotient)
    remainder = dividend % divisor
    denomenator = divisor

    # Hahahah just in case hahahaha
    final = "Could not find answer."

    if mode == 0:
        final = str(rounded) + " Remainder: " + str(remainder)
    elif mode == 1:
        final = str(rounded) + " " + "{}".format(simplifyFraction(remainder,denomenator))
    return final


"""
Parameters are lists of integers
Minuend (LIST[INT])
Subtrahend (LIST[INT])

Example problem:
7 3/10 - 4 1/2 = ???

Usage for solution:
mixedSub([7,3,10],[4,1,2]) --> 2 4 / 5
"""
def mixedSub(minuend,subtrahend):

    # Whole number parts are fairly straight forward.
    subWhole = subtrahend[0]
    minWhole = minuend[0]
    finalWhole = minWhole - subWhole

    # Find common denomenator.
    minDem = minuend[2]
    subDem = subtrahend[2]
    commondem =  minDem * subDem

    # Find the numerator of the final.
    minNum = minuend[1]
    subNum = subtrahend[1]
    newMinNum = minNum*subDem
    newSubNum = minDem*subNum
    finalSum =  newMinNum - newSubNum
    
    # Handling cases where carrying is needed.
    if finalSum < 0:

        finalWhole -= 1
        finalSum += commondem

    # Final answer.
    finalFrac = simplifyFraction(finalSum,commondem)
    return "{} {}".format(finalWhole,finalFrac)

"""
Adds mixed numbers, parameters are lists of integers
firstNum (LIST[INT])
secondNum (LIST[INT])

Entry of numbers looks like this:
3 1/2 --> [3,1,2]

Also works for subtraction, you need only change the sign of the first number,
just as you would in writing.
Example problem:
7 3/10 - 4 1/2 = ???

Usage for solution:
mixedSub([7,3,10],[-4,1,2]) --> 2 4 / 5
"""
def addMix(firstNum,secondNum):
    
    # Negative handling, this is why
    # only the first number should be negative.
    for n in [firstNum,secondNum]:
        if n[0] < 0:
            n[1] *= -1
    
    # Breaking down the inputs into usable ints:
    # Whole number
    firstWhole = firstNum[0]
    secondWhole = secondNum[0]

    # Here, nume is short for numerator and NOT number.
    firstNume = firstNum[1]
    secondNume = secondNum[1]

    # Denomenator
    firstDen = firstNum[2]
    secondDen = secondNum[2]
    commonDen = firstDen * secondDen

    # Conversion into improper fractions, the denomenator is
    # Known, it's commonDen, it's just the numerators that need
    # Calculating.
    firstWhole *= commonDen
    secondWhole *= commonDen
    firstConvNume = firstNume * secondDen + firstWhole
    secondConvNume = secondNume * firstDen + secondWhole
    improperNume = firstConvNume + secondConvNume

    # No need to do any other stuff, we have a function that can do this.
    return(longDiv(improperNume,commonDen,mode=1))