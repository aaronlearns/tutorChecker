import math
from collections import Counter

"""
The following is a grepper answer by Noah's Nerdy KnowHow:
https://www.codegrepper.com/profile/noahs-nerdy-knowhow

The original function returned a dict, I added some code to make it a list.
"""
# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
def primeFactors(num):
        ps = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,
        37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,
        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149]
        # Primes from https://primes.utm.edu/lists/small/10000.txt.
        # Primes can also be generated by iterating through numbers
        # and checking for factors, or by using a probabilistic test
        # like Rabin-Miller.
        pdict = {}
        for p in ps:
                if p <= num:
                        while (num / p).is_integer():
                                if str(p) in pdict:
                                        pdict[str(p)] += 1
                                else:
                                        pdict[str(p)] = 1
                                num /= p
                if num == 1: break
        
        """
        Added this to turn output to a raw list.
        """
        pList = []
        for i,key in enumerate(pdict):
            keys = list(pdict.keys())
            for n in range(0,pdict[key]):
                pList.append(int(keys[i]))
        return pList
# <><><><><><><><><><><><><><><><><><><><><><><><><><><>

"""
This function finds GCF (greatest common factor) or LCM (least common multiple)
of two numbers.

The algorithm is as follows:
>Taking the sets of the numbers' prime factors as lists
>Performing some operation on all of them to get a new list
>Finding the product of all the final list's elements.

For GCF, the operation is finding the intersection of all the lists.
For LCm, the operation is the union of all the lists.

Technically, we could do this for more than two numbers,
and I've made it as such, but I'm not sure the runtime's that good.

Example problems:
1. Find the GCF of 77 and 91
Solution:
gcflcm(77,91) --> 7
2. Find the LCM of 30 and 8
Solution
gcflcm(8,30,gcf=False) --> 120

"""
def gcflcm(*nums, gcf=True):

    for num in nums:
        if type(num) != int:
            raise Exception("All parameters must be integers.")

    factorLists = []
    for num in nums:
        factorLists.append(primeFactors(num))
    
    final = 1
    primeSet = factorLists[0]
    if gcf:
        for n in range(1, len(factorLists)):

            # "intersection" in python is not the same as it is in set theory :))))))
            primeSet = (Counter(primeSet) & Counter(factorLists[n])).elements()
            primeSet = list(primeSet)

    else:
        for n in range(1, len(factorLists)):

            # The reason I used this library and not set1.union(set2) is that this
            # library preserves duplicates.
            primeSet = (Counter(primeSet) | Counter(factorLists[n])).elements()
            primeSet = list(primeSet)

    # Getting the product of all the elements.
    for fac in primeSet:
        final *= fac
    return final
# print(gcflcm(8,30,gcf=False))
# print(gcflcm(77,91))

"""
Pretty self explanatory, parameter types below.

numerator (INT) numerator of the fraction to be simplified.
denomenator (INT) denomenator of the fraction to be simplified.
"""
def simplifyFraction(numerator,denomenator):
    for num in [numerator,denomenator]:
        if type(num) != int:
            raise Exception("Both numerator and denomenator must be an integer.")
    
    # Divide by zero error-catching.
    if denomenator == 0:
        raise Exception("Denomenator can not be zero!")
    factor = gcflcm(numerator,denomenator)
    newNum = int(numerator / factor)
    newDem = int(denomenator / factor)
    final = "{} / {}".format(newNum,newDem)
    return final
# print(simplifyFraction(18,96))

"""
The crown jewel of this whole file.
Solves long divison as follows:
        __________
 divisor| dividend 

dividend (INT)
divisor (INT)
mode (INT 0-2)
> 0 - Returns the answer with a remainder ex. longDiv(63,4) --> 15 Remainder: 3
> 1 - Returns the answer as a mixed number ex. longDiv(63,4,mode=1) --> 15 3 / 4
> 2 - Returns the answer as a decimal ex. longDiv(63,4,mode=2) --> 15.75
"""
def longDiv(dividend,divisor,mode=0):        
    
    for num in [dividend,divisor,mode]:
        if type(num) != int:
            raise Exception("All parameters must be integers.")

    # Decimal division is the easiest on the checking side.
    quotient = dividend / divisor
    if mode == 2:
        return quotient
    
    # Isolating the fractional part from the whole part.
    rounded = math.floor(quotient)
    remainder = dividend % divisor
    denomenator = divisor

    # Hahahah just in case hahahaha
    final = "Could not find answer."

    if mode == 0:
        final = str(rounded) + " Remainder: " + str(remainder)
    elif mode == 1:
        final = str(rounded) + " " + "{}".format(simplifyFraction(remainder,denomenator))
    return final
# print(longDiv(63,4,mode=1))

"""
Adds mixed numbers, parameters are lists of integers
firstNum (LIST[INT])
secondNum (LIST[INT])

Entry of numbers looks like this:
3 1/2 --> [3,1,2]

Also works for subtraction, you need only change the sign of the first number,
just as you would in writing.
Example problem:
7 3/10 - 4 1/2 = ???

Usage for solution:
addMix([7,3,10],[-4,1,2]) --> 2 4 / 5
"""
def addMix(firstNum,secondNum):

    for num in [firstNum,secondNum]:
        if type(num) != int:
            raise Exception("All parameters must be integers.")
    
    # Negative handling, this is why
    # only the first number should be negative.
    for n in [firstNum,secondNum]:
        if n[0] < 0:
            n[1] *= -1
    
    # Breaking down the inputs into usable ints:
    # Whole number
    firstWhole = firstNum[0]
    secondWhole = secondNum[0]

    # Here, nume is short for numerator and NOT number.
    firstNume = firstNum[1]
    secondNume = secondNum[1]

    # Denomenator
    firstDen = firstNum[2]
    secondDen = secondNum[2]
    commonDen = firstDen * secondDen

    # Conversion into improper fractions, the denomenator is
    # Known, it's commonDen, it's just the numerators that need
    # Calculating.
    firstWhole *= commonDen
    secondWhole *= commonDen
    firstConvNume = firstNume * secondDen + firstWhole
    secondConvNume = secondNume * firstDen + secondWhole
    improperNume = firstConvNume + secondConvNume

    # No need to write any more code, note that longDiv is
    # set to return a mixed number.
    return(longDiv(improperNume,commonDen,mode=1))
# print(addMix([7,3,10],[-4,1,2]))