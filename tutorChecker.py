import math
from collections import Counter

"""
The following function is a grepper answer by Noah's Nerdy KnowHow:
https://www.codegrepper.com/profile/noahs-nerdy-knowhow

If you have Grepper, it came from this search:
https://www.google.com/search?q=returns+prime+factors+of+a+number+python&rlz=1C1RXQR_enUS984US984&oq=returns+prime+factors+of+a+number+python&aqs=chrome..69i57.6871j1j4&sourceid=chrome&ie=UTF-8

It returns the prime factors of a number in the form of a dict,
I added some code to change the output to a list.
"""
# <><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
def primeFactors(num):
        ps = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,
        37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,
        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149]
        # Primes from https://primes.utm.edu/lists/small/10000.txt.
        # Primes can also be generated by iterating through numbers
        # and checking for factors, or by using a probabilistic test
        # like Rabin-Miller.
        pdict = {}
        for p in ps:
                if p <= num:
                        while (num / p).is_integer():
                                if str(p) in pdict:
                                        pdict[str(p)] += 1
                                else:
                                        pdict[str(p)] = 1
                                num /= p
                if num == 1: break
        
        """
        Added this to turn output to a raw list.
        """
        pList = []
        for i,key in enumerate(pdict):
            keys = list(pdict.keys())
            for n in range(0,pdict[key]):
                pList.append(int(keys[i]))
        return pList
# <><><><><><><><><><><><><><><><><><><><><><><><><><><>

"""
The function below finds GCF (greatest common factor) or LCM (least common multiple)
of two numbers depending on how a boolean is set. The default is GCF.

Both problem types are in the same function because of an algorithm
that's very similar for GCF and LCM, save one small difference.

The algorithm is as follows:
>Taking the sets of the numbers' prime factors as lists.
>Performing some operation on all of the lists to get a final list.
>Finding the product of all the final list's elements.

For GCF, the operation is finding the INTERSECTION of all the lists.
For LCM, the operation is the UNION of all the lists.

Technically, we could do this for more than two numbers,
and I've made it as such, but I'm not sure the runtime's that good.

Example problems:
1. Find the GCF of 77 and 91
Solution:
gcflcm(77,91) --> 7

2. Find the LCM of 30 and 8
Solution
gcflcm(8,30,gcf=False) --> 120
"""
def gcflcm(*nums, gcf=True):

    for num in nums:
        if type(num) != int:
            raise Exception("All parameters must be integers.")

    # Getting the list of prime factors for all the numbers.
    factorLists = []
    for num in nums:
        factorLists.append(primeFactors(num))

    # We loop through all the lists and perform the desired operation on them
    # depending on whether we're in GCF or LCM.
    final = 1
    primeSet = factorLists[0]
    if gcf:
        for n in range(1, len(factorLists)):

            # "intersection" in python is not the same as it is in set theory :))))))
            primeSet = (Counter(primeSet) & Counter(factorLists[n])).elements()
            primeSet = list(primeSet)
    else:
        for n in range(1, len(factorLists)):

            # The reason I used this library and not set1.union(set2) is that this
            # library preserves duplicates.
            primeSet = (Counter(primeSet) | Counter(factorLists[n])).elements()
            primeSet = list(primeSet)

    # Getting the product of all the elements in the final list.
    for fac in primeSet:
        final *= fac
    return final
# print(gcflcm(77,91))
# print(gcflcm(8,30,gcf=False))

"""
Hahaha it says "simp" hahaha, parameter types below.

numerator (INT) numerator of the fraction to be simplified.
denomenator (INT) denomenator of the fraction to be simplified.

Example problem:
Simplify 18 / 96
Solution:
simpFrac(18,96) --> 3 / 16
"""
def simpFrac(numerator,denomenator):

    # Type checking.
    for num in [numerator,denomenator]:
        if type(num) != int:
            raise Exception("Both numerator and denomenator must be an integer.")
    
    # Divide by zero error-catching.
    if denomenator == 0:
        raise Exception("Denomenator can not be zero!")
    
    # Simplifying the fraction by finding the GCF.
    factor = gcflcm(numerator,denomenator)
    newNum = int(numerator / factor)
    newDem = int(denomenator / factor)

    final = "{} / {}".format(newNum,newDem)
    return final
# print(simpFrac(18,96))

"""
The crown jewel of this whole file. There is nothing harder than
long divison.

Solves long divison as follows:
        __________
 divisor| dividend 
Example problem:
 ____
4|62
dividend (INT)
divisor (INT)
mode (INT 0-2)
> 0 - Returns the answer with a remainder ex. longDiv(63,4) --> 15 Remainder: 2
> 1 - Returns the answer as a mixed number ex. longDiv(63,4,mode=1) --> 15 1 / 2
> 2 - Returns the answer as a decimal ex. longDiv(63,4,mode=2) --> 15.5
"""
def longDiv(dividend,divisor,mode=0):        
    
    # Type-checking.
    for num in [dividend,divisor,mode]:
        if type(num) != int:
            raise Exception("All parameters must be integers.")

    # Decimal division is the easiest on the checking side.
    quotient = dividend / divisor
    if mode == 2:
        return quotient
    
    # Isolating the fractional part from the whole part.
    rounded = math.floor(quotient)
    remainder = dividend % divisor
    denomenator = divisor

    # Hahahah just in case hahahaha
    final = "Could not find answer."

    # Mode handling
    if mode == 0:
        final = str(rounded) + " Remainder: " + str(remainder)
    elif mode == 1:
        final = str(rounded) + " " + "{}".format(simpFrac(remainder,denomenator))
    return final
# print(longDiv(62,4,mode=0))
# print(longDiv(62,4,mode=1))
# print(longDiv(62,4,mode=2))

"""
Adds mixed numbers

Entry of numbers looks like this:
3 1/2 --> [3,1,2]

Also works for subtraction, you need only change the sign of the first number,
just as you would in writing.

Example problems:
1. 7 3/10 + 4 3/4 = ???
Solution:
addMix([7,3,10],[4,1,2]) --> 11 4 / 5

2. 7 3/10 - 4 3/4 = ???
Solution:
addMix([7,3,10],[-4,1,2]) --> 2 4 / 5

Parameters are lists of integers
firstNum (LIST[INT])
secondNum (LIST[INT])
"""
def addMix(firstNum,secondNum):

    # Type-checking.
    for li in [firstNum,secondNum]:
        for num in li:
            if type(num) != int:
                raise Exception("All parameters must be integers.")
    
    # Negative handling, this is why for negative numbers,
    # only the first number in the INT list should be negative.
    for n in [firstNum,secondNum]:
        if n[0] < 0:
            n[1] *= -1
    
    # Breaking down the inputs into usable ints:
    # Whole number
    firstWhole = firstNum[0]
    secondWhole = secondNum[0]

    # Here, nume is short for numerator and NOT number.
    firstNume = firstNum[1]
    secondNume = secondNum[1]

    # Denomenator
    firstDen = firstNum[2]
    secondDen = secondNum[2]
    commonDen = firstDen * secondDen

    # Conversion into improper fractions, the denomenator is
    # Known, it's commonDen, it's just the numerators that need
    # Calculating.
    firstWhole *= commonDen
    secondWhole *= commonDen
    firstConvNume = (firstNume * secondDen) + firstWhole
    secondConvNume = (secondNume * firstDen) + secondWhole
    improperNume = firstConvNume + secondConvNume

    # No need to write any more code, note that longDiv is
    # set to return a mixed number.
    return(longDiv(improperNume,commonDen,mode=1))
# print(addMix([7,3,10],[4,3,4]))
# print(addMix([7,3,10],[-4,3,4]))